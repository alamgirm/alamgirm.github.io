<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>https://alamgirm.github.io/blog</title>
   
   <link>https://alamgirm.github.io</link>
   <description>Programming, Automation, Data Science, Machine Learning, Visualizations, Arduino, Raspberry Pi and other IoT.</description>
   <language>en_GB</language>
   <managingEditor> alamgir</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Barebone AVR Programming - LED Blinker</title>
	  <link>/blog//Barebone-AVR-Programming-LED-Blinker</link>
	  <author>alamgir</author>
	  <pubDate>2017-08-09T16:18:00-04:00</pubDate>
	  <guid>/blog//Barebone-AVR-Programming-LED-Blinker</guid>
	  <description><![CDATA[
	     <p><img src="assets/images/2017/2017_08_09_AVR_board.png" alt="AVR Board" class="leftimg" />
Arduino is fun and easy, and it gives the best introducton to AVR processors. However, if you want to build something useful, you’ll soon hit the wall. Arduinio has a huge collection of shields, and supporting libraries for them, but developing a well-designed system is difficult when it comes to debugging. This is due to the fact that Arduino IDE hides most of the intricacies of AVR MCU. If you are used to debug program using breakpoints, stepping and tracing through lines of code, the Arduino IDE is no help. The AVR Studio development environment from Atmel is the saviour here. However, it can’t connect to an Arduino board through the USB port. Fortunately, most Arduino boards have a special header called ICE (in-circuit-emulator), which is actually an SPI (serial peripheral interface) connector. A special hardware tool, for example AVR ISP MK II is needed to connect. There are other alternatives too.
<!--more--></p>

<h3 id="avr-dev-board">AVR dev-board</h3>
<p>An alternative to Arduino board is to use a development board. Retailer websites like <a href="http://aliexpress.com">Aliexpress</a> have good ranges of development boards with Atmel processors. In this post, I have used the board found <a href="https://www.aliexpress.com/item/1PCS-DC-5V-ATmega128-AVR-Core-Development-Board-Minimum-System-Module-ISP-JTAG/32745789402.html">here</a>. The board uses an ATMega128 chip, has both JTAG and ISP connectors, could be powered by external power supply or from the JTAG. There is an on-board toggle switch to change power supply source. the As an addedd bonus the board has two LEDs connected to bits 0 and 1 of port A. This is quite useful for testing the board. If desired the LEDs can be disconnected by taking the jumper (next to LEDs) off.</p>

<h3 id="programmer-device">Programmer device</h3>
<p>You might know that the Arduino IDE uploads program (compiled sketches) to an Ardiuno board using serial port (emulated over the USB). Under the hood there is also a small program, already put into the flash memory of the board during manufacturing, handles the receiving of program code from Arduino IDE and writes onto the flash memory. That piece of code is often called Arduino bootloader (not in tradional meaning of booting off course). The actuall uploading of program is handled by a software tool called <code class="highlighter-rouge">avrdude</code>. It is possible to use <code class="highlighter-rouge">avrdude</code> to manually upload program as long as the <code class="highlighter-rouge">MCU</code> has the bootlaoder installed. For the dev-board I am using, there is no bootloader, so we need either a JTAG or ICE hardware tool. Such tools don’t need any helper other than the MCU itself. For the porpose of this post, I used a JTAG programmer tool. The JTAG programmer/debugger I used is bought from <a href="https://www.aliexpress.com/item/Free-shipping-AVR-USB-Emulator-debugger-programmer-JTAG-ICE-for-Atmel/623898152.html">Aliexpress</a>. 
<img src="assets/images/2017/2017_08_09_JTAG_programmer.png" alt="JTAG debugger programmer" /></p>

<h3 id="programming-setup">Programming setup</h3>
<p>I’ll write a simple test program in C language to check the dev-board. The best way of doing this (for programmers with deskop programming background) is to use the IDE provided by Atmel. For this post I used AVR Studio version 4.18. Though the latest version is 7, for beginners to keep things under control version 4 is just adequate.</p>

<p>So, if you are following to do the same, download and install AVR Studio (it only runs on Windows). The installer also installs the USB driver software required to use the JTAG programmer.</p>

<p>If everything goes smooth, run AVR Studio and select a new project. Provide a name and location for the project, and select Project type: <code class="highlighter-rouge">AVR GCC</code>. Hitting Next will bring the Degug/programming platform, choose JTAG ICE (or the suitable one based on your programmer), and the MCU type. The board I am using has an ATMega128.</p>

<p>I named the project TestBoard, the wizard created the project and an empty file named TestBoard.c.
Following is the code I typed in into TestBoard.c file.</p>

<pre>
	//
	//	File name: TestBoard.c
	//	Purpose: Alternately blinks the two LEDs connected 
	//           at Port A bit 0 and bit 1.
	//
	
	#define F_CPU 1000000

	#include &lt;avr/io.h&gt;
	#include &lt;util/delay.h&gt;

	int main (void)
	{
		// all bits in Port A are set as Output
		DDRA = 0xFF;
		// send out all zeros to turn OFF the LEDs
		PORTA = 0x00;

		while(1) {

			// LED on PA.0 is ON, PA.1 is OFF
			PORTA = 0x01; // binary 0000 0001 

			_delay_ms(1000); // delay 1 sec
	
			// LED on PA.0 is OFF, PA.1 is ON
			PORTA = 0x02; // binary 0000 0010
	
			_delay_ms(1000); // delay 1 sec	
		}

	return 0;
	}
	
</pre>

<h3 id="explanation">Explanation</h3>
<p>The C program code first defines the processor clock frequncy via <code class="highlighter-rouge">F_CPU</code>. This is required for the delay functions used in the program. The program first initializes Port A as all output, and sends zero to the port A. This turns the LEDs off (if they were ON before). Then we enter a loop where we first write 1 to first LED and 0 to second LED. After a second delay, we write 0 to first LED and 1 to the second LED. Then again a second of delay. This gives an impression of alternate flushing LEDs.</p>

<h3 id="output">Output</h3>
<p>A short clip showing the LEDs <a href="assets/images/2017/2017_08_09_LED_Blinking.3gp">blinking</a>.</p>

<h3 id="links-to-software-and-hardware">Links to software and hardware</h3>

<ul>
  <li>The <a href="https://www.aliexpress.com/item/1PCS-DC-5V-ATmega128-AVR-Core-Development-Board-Minimum-System-Module-ISP-JTAG/32745789402.html">development board</a>.</li>
  <li>JTAG <a href="https://www.aliexpress.com/item/Free-shipping-AVR-USB-Emulator-debugger-programmer-JTAG-ICE-for-Atmel/623898152.html">debugger/programmer</a>.</li>
  <li>Atmel <a href="http://www.atmel.com/tools/studioarchive.aspx">AVR Studio</a>. Scroll down for 4.18.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Inside ATMega AVR microcontroller</title>
	  <link>/blog//Inside-ATmega-AVR</link>
	  <author>alamgir</author>
	  <pubDate>2017-06-14T08:18:00-04:00</pubDate>
	  <guid>/blog//Inside-ATmega-AVR</guid>
	  <description><![CDATA[
	     <p><img src="assets/images/2017/17_06_14_ATmega328P.jpg" alt="Atmel ATmega328P" class="rightimg" />Atmel offers a wide variety of AVR MCU available in different series or families. MCU from these families differ in capabilities and funcionalities and sometimes in instructions available and architecture. However,  the design of AVR itself followes some common philosophy that could help us understand the internal architecture of such an MCU. In this post we talk about Atmel ATmega MCU which are available in different parts numbers, and with differnt amount of program memory.</p>

<!--more-->

<h2 id="internal-architecture-of-atmega-family">Internal Architecture of ATmega family</h2>
<p>Looking at the block diagram of internal architecture of ATmega family one would notice that the MPU has:</p>

<ul>
  <li>Serial I/O communication for dowanloading of program</li>
  <li>Flash memory for storing program to be executed</li>
  <li>EEPROM (for storing CPU configuration bits)</li>
  <li>Peripheral I/O</li>
  <li>Analog/Digital converter</li>
  <li>Timers/counters</li>
  <li>Data memory</li>
  <li>CPU core (ALU, Program counter, general purpose registers etc)</li>
</ul>

<p><img src="assets/images/2017/17_06_14_Atmel_ATmega_arch.png" alt="Atmel ATmega" title="Atmel ATmega MPU." /></p>

<p>AVR is based on modidfied Harvard architecture, so it is expected the program and data memory space tos be seperate. In addition to that, AVR allows readonly access to any data residing in the program memory, but no writes are allowed by the program itself. In addition to the memories for data and programs, AVR also has few bits of EEPROM for storing CPU configuration parameters (we’ll see later). When compared to a CPU like Intel 8080 or Zilog Z80, the ATmega has lots of other functionalities buil-it, to be justly called a microcontroller. Lets talk them in detail:</p>

<h4 id="serial-io">Serial I/O</h4>
<p>While Intel 8080 or Zilog Z80 needs a UART chip to communicate with the outside world via serial connection, ATmega has this functionality built right into the chip making serial communication trivial. Some chips offer USB commucations too.</p>

<h4 id="memories">Memories</h4>
<p>ATmega has flash memory for storing programs, and EEPROM for storing configuration parameters. Contents of both these memories are preserved when the power is off. Both these can be written from outside with appropriate tool. For storing temporary data there is data memory, which is in fact static RAM. The exact amount of thse memories vary depending on the model number.</p>

<h4 id="cpu">CPU</h4>
<p>The CPU core in AVR like most other CPU has ALU, Program Counter, and a host of general purspose registers. ATmega has 32 general purpose registers, each being 8-bit wide. The number and usage can slightly vary depending on the model. Surprisingly enough, these registers are mapped to first 32 bytes of the data memory. This meeans a program whishing to access the registers can simply read/wirte data to the specific memory locations. Last six of the 32 regisers are used as index registers, each in a 16-bit wide fashion. PC (program counter), a 14-bit special purpose register, points to the next executable instruction in <i>program memory</i>. When the MCU is first powered up, or reset, the PC is loaded to with value <code class="highlighter-rouge">0x0000</code> (this could be changed though). The SP (stack pointer) consists of two registers (taken from the total 32) and points to a memory location in <i>data memory</i>. In addition, AVR has few status regisers to reflect various operational status.</p>

<h4 id="peripheral-io">Peripheral I/O</h4>
<p>ATmega supports digital input/output of data with outside world, most likely from the same board. Some of these I/O can be analog, PWM (pulse width modulated) signals, others could be simple TTL (transistor transisto logic). Specilized communicatoin such as I2C, SPI, CAN bus can also be supported with proper support circuit and programs. Often there is an analog comparator that could be used for comparing analog signals. Digital data from/to outside world are stored in memory locations starting right after the 32 registers map. Though these locations are called I/O registers, they are not CPU registers, just ordinary memory locations mapped as an I/O port. Depending on model there could be 64 or more I/O registers.</p>

<h4 id="analogdigital-converter">Analog/Digital Converter</h4>
<p>ATmega has in-built A/D (Analog to Digital) converter. Some models have D/A (Digital to Analof) converter too. This allows interfacing with analog world without needing extranal A/D chips.</p>

<h4 id="timerscounters">Timers/Counters</h4>
<p>ATmega has on chip timers/counters, and thre are two kinds. The first kind is a 8-bit synchronous where the clock signal is derived from the CPU clock. The second kinds allows connecting an external clock circtuit to trigger the timer/counter and works independent of the CPU clock. Each of the timer/counter available can operate in a multiple of modes depending on application needs.
<img src="/assets/images/2017/17_06_14_Atmel_ATmega_arch2.png" alt="Atmel ATmega" title="Atmel ATmega MPU." /></p>

<h5 id="other-features">Other Features</h5>

<p>Depending on the model, certain models can have special sensors built-in, can have an LCD driver, LIN bus support etc.</p>

<h4 id="pin-configurations">Pin configurations</h4>
<p>An ATmega chip has many more functions than it has physical pins to support them for. To determine which functionalities are avalilable at which pins, ATmega has something called control register. Changing a suitable bit in the register can make a pin digital or analog, input or output, attach an intenal pull-up resistance etc. The timers/counters, communication interface, A/D etc can be configured by adjusting bits in the configuration control registers. The expectation with such design is that the user would configure the chip for his application need and the chip would just operate the way it is configured.</p>

<h4 id="watchdog-timer">Watchdog timer</h4>
<p>Though not shown in the picture, ATmega chips have a special timer, still programmable, called watchdog timer. This allows user programs or say an operating system to watch the MCU if it is stuck in a program execution. If that happens, a separate circuit can reset the MCU witout human intervention.</p>

<h4 id="credits">Credits</h4>
<ul>
  <li>The pictures in this article are courtesy of <a href="http://shop.oreilly.com/product/0636920037880.do">Arduino- A technical reference</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Modern microcontroller: AVR series</title>
	  <link>/blog//modern-microcontroller-avr-group</link>
	  <author>alamgir</author>
	  <pubDate>2017-06-13T02:18:00-04:00</pubDate>
	  <guid>/blog//modern-microcontroller-avr-group</guid>
	  <description><![CDATA[
	     <p>The story of AVR familiies of microcontrollers (MCU), that power popular Arduino development boards began with two Norwegian students who designed a microcontroller as academic project. It was based on modified Harvard achitecture and RISC instructions set. The design later bought up by Atmel, and the two original designers continued to work on and improve. <img src="assets/images/2017/17_06_13_Atmel_AVR_logo.png" alt="AVR logo" class="rightimg" /> Atmel, understandly targetting the market of Intel 8051 releases the first AVR AT90S8515, a 8-bit MCU with same pin out as Intel 8051. Though originally 8-bit today AVR has 32-bit MCU, and offers multiple families of MCU with varied degree of capabilities and functionalities. There are however few common features: for example use of on-chip flash memory for program storage, EEPROM bits for CPU configuration flags etc. Within each family there are multiple MCUs available.</p>

<!--more-->

<h2 id="avr-families">AVR Families</h2>
<p>AVR MCUs are generally put into any of the following falimies:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>TinyAVR</th>
      <th>MegaAVR</th>
      <th>XMEGA</th>
      <th>AVR32</th>
      <th>App Specific</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Data memory</td>
      <td>uptp 1024</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Word size</td>
      <td>8-bit</td>
      <td>8-bit</td>
      <td>8-bit</td>
      <td>32-bit</td>
      <td>depends</td>
    </tr>
    <tr>
      <td>Program memory</td>
      <td>0.5 to 16KB</td>
      <td>4-256KB</td>
      <td>16-384KB</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Package</td>
      <td>6-32 pin</td>
      <td>28-100pin</td>
      <td>variable</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Peripheral</td>
      <td>limited</td>
      <td>extened</td>
      <td>extended</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Instrunctions</td>
      <td>Some limit</td>
      <td>Extened</td>
      <td>Extened</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Extra feature</td>
      <td>No</td>
      <td>Option</td>
      <td>Option</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="specific-models">Specific Models</h2>
<p>Below are some specifuc models that are used often. The table is not complete, and accuracy is not guranteed.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Flash memory</th>
      <th>EEPROM</th>
      <th>SRAM</th>
      <th>Chip pins</th>
      <th>I/O pins</th>
      <th>Clock</th>
      <th>Feature</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ATtiny13</td>
      <td>1K</td>
      <td>64</td>
      <td>160</td>
      <td>8</td>
      <td>6</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATtiny85</td>
      <td>8K</td>
      <td>512</td>
      <td>512</td>
      <td>8</td>
      <td>6</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATMega32</td>
      <td>32K</td>
      <td>1K</td>
      <td>2K</td>
      <td>40</td>
      <td>32</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega32U4</td>
      <td>32K</td>
      <td> </td>
      <td> </td>
      <td>44</td>
      <td>26</td>
      <td>16MHz</td>
      <td>USB</td>
    </tr>
    <tr>
      <td>ATmega128</td>
      <td>128K</td>
      <td> </td>
      <td> </td>
      <td>64</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega168</td>
      <td>16K</td>
      <td>512</td>
      <td>1K</td>
      <td>28/32</td>
      <td>23</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega328</td>
      <td>32K</td>
      <td>1K</td>
      <td>2K</td>
      <td>28/32</td>
      <td>23</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega649</td>
      <td>64K</td>
      <td> </td>
      <td> </td>
      <td>64</td>
      <td> </td>
      <td> </td>
      <td>LSB</td>
    </tr>
    <tr>
      <td>ATmega1280</td>
      <td>128K</td>
      <td> </td>
      <td> </td>
      <td>100</td>
      <td>86</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega2560</td>
      <td>256K</td>
      <td> </td>
      <td> </td>
      <td>100</td>
      <td>86</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="more-details">More details</h3>

<p>More details about the features of various families can be found in <a href="http://www.atmel.com/products/microcontrollers/avr/default.aspx">Atmel’s web</a> site. Considering both the price and features, ATMega family is probably the best choice among IoT and hooby users. Choices and details about ATMega family chips are available <a href="http://www.atmel.com/products/microcontrollers/avr/megaavr.aspx"> here.</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
