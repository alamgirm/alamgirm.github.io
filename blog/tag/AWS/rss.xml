<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>https://alamgirm.github.io/blog</title>
   
   <link>https://alamgirm.github.io</link>
   <description>Programming, Automation, Data Science, Machine Learning, Visualizations, Arduino, Raspberry Pi and other IoT.</description>
   <language>en_GB</language>
   <managingEditor> alamgir</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Continuous Integration and Continuous Development on AWS : part III - Ansible</title>
	  <link>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-III</link>
	  <author>alamgir</author>
	  <pubDate>2017-12-16T15:18:00-05:00</pubDate>
	  <guid>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-III</guid>
	  <description><![CDATA[
	     <p><img src="/blog/assets/images/2017/17_12_16/cicd-0.png" alt="CICD" class="leftimg" />
DevOps philosophy has it that an application is better developed, tested and deployed in small pieces, in a continuous manner. This hopefully serves the changing requirements (of the clients or users) in both time and cost effective way. The developers, and operational team also always have something that is proved to be working, something to roll back to in case a change does not end successfully. To practically embrace the philosphy there needs to be an organizational pipeline where the teams (development, QA testing, deployment, monitoring etc) participate. And for better communication among the teams, most if not all teams use same kind of automation tools/platforms. This post is the first in a series of posts that talks about automation tools, employed on Amazon AWS cloud platform.</p>

<!--more-->

<ol>
  <li>loginto the Ansible Controller instance</li>
  <li>
    <p>Update packages and install pip (that will install ansible). For RH epel needs to be installed first</p>

    <pre>
- Sudo to root: $ sudo su
- Update the OS:# yum -y update
- Install wget: # yum -y install wget
- Download epel repo: # wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
- Install epel repo: # yum -y install epel-release-latest-7.noarch.rpm 
</pre>
  </li>
</ol>

<p>Now the pip installer</p>

<pre>
   - Install pip: # yum -y install python-pip
   - Install ansible: # pip install ansible
   </pre>

<ol>
  <li>
    <p>Install git client</p>

    <pre>
# yum -y install git
</pre>
  </li>
  <li>
    <p>Copy the private key file <code class="highlighter-rouge">HostForAnsibleKey.pem</code> into the home directory.
The controller node need this key to access the host.</p>
  </li>
  <li>
    <p>Manually create an inventory of all the resources. Store it as <code class="highlighter-rouge">/etc/ansible/hosts</code></p>

    <pre>
[test-servers]
 10.179.44.7
</pre>
  </li>
</ol>

<p>[ Alternatively I could use the ec2.py script to list]</p>

<ol>
  <li>Configure ansible. Create a file named <code class="highlighter-rouge">ansible.cfg</code> inside folder <code class="highlighter-rouge">ansible</code>.</li>
</ol>

<pre>
[defaults]
inventory     = /etc/ansible/hosts
remote_user   = ec2-user
become        = True
become_method = sudo
become_user   = root
nocows        = 1
</pre>

<ol>
  <li>Check and see if ansible can access the host.</li>
</ol>

<pre>
ansible -m ping 'test-servers' --private-key ../HostForAnsibleKey.pem
</pre>

<p>If it works fine, the result should be:</p>

<pre>
10.179.44.7 | SUCCESS =&gt; {
    "changed": false, 
    "ping": "pong"
}
</pre>

<h3 id="creating-an-ansible-playbook">Creating an ansible playbook</h3>

<h3 id="creating-helloworld-app">Creating HelloWorld app</h3>
<ol>
  <li>inside ansible folder, create a new folder named roles.</li>
  <li><code class="highlighter-rouge">ansible-galaxy init nodejs</code> creates a new role nodejs
 We’ll use this role to install nodejs on to the target system</li>
  <li>Go inside nodejs, then tasks and edit file main.yml</li>
</ol>
<pre>
---
# tasks file for nodejs

- name: Installing nodejs and npm
  yum:
    name: ""
    enablerepo: epel
    state: installed
  with_items:
    - nodejs
    - npm
</pre>
<p>Whenever ansible runs, it will check the existence of these package, if not found will install.</p>

<ol>
  <li>Another role is needed to install and run the app. Go back to roles folder, and issue
<code class="highlighter-rouge">ansible-galaxy init helloworld</code>. After the role creattion go inside, helloworld and then files.</li>
  <li>This folders contains files that ansible can upload to the target. Lets get 2 files from web (ideally we’d get them from github)</li>
</ol>
<pre>
wget http://bit.ly/2vESNuc -O files/helloworld.js
</pre>
<ol>
  <li>Now go inside the task folder (under helloworld) and edit main.yml file</li>
</ol>
<pre>
- name: Copying the application files
  copy:
    src: helloworld.js
    dest: /home/ec2-user/
    owner: ec2-user
    group: ec2-user
    mode: 0644
  notify: restart helloworld

- name: Copying the upstart file
  copy:
     src: helloworld.conf
     dest: /etc/init/helloworld.conf
     owner: root
     group: root
     mode: 0644

- name: Starting the HelloWorld nodejs service
  service:
      name: helloworld
      state: started
</pre>

<p>Now need to add a handler. Head to folder handlers under helloworld. Edit main.yml</p>
<pre>
- name: restart helloworld
  service:
      name: helloworld
      state: restarted
</pre>

<p>Module dependency. The app needs node4j to run. Open meta/main.yml
At the bottom, remove [] and make it appear</p>
<pre>
dependencies:
   - pre_req
   - nodejs
</pre>

<h3 id="main-playbook-file">Main Playbook file</h3>
<p>Here is the main playbook file</p>
<pre>
---
- hosts: test_servers
  become: yes
  roles:
     - helloworld
</pre>

<p>Now play the playbook file:
<code class="highlighter-rouge">ansible-playbook helloworld.yml --private-key ../HostForAnsibleKey.pem</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>Continuous Integration and Continuous Deployment on AWS : part II - CloudFormation</title>
	  <link>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-II</link>
	  <author>alamgir</author>
	  <pubDate>2017-12-16T15:18:00-05:00</pubDate>
	  <guid>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-II</guid>
	  <description><![CDATA[
	     <p><img src="/blog/assets/images/2017/17_12_16/cicd-0.png" alt="CICD" class="leftimg" />
In the <a href="/blog/Continuous-Integration-and-Continuous-Development-using-AWS-part-I.html"> last post</a> we created a limited-rights IAM user that we’ll use in this post and in future posts to create different infrastructure resources on AWS Cloud. We can defintely use the account to login into AWS Management Console, and create and manage resources, but that would be too tedious for not-too-small project, and more importatnly against the philosohpy of DevOps. In DevOps philosophy we’d like to automate everything, including creating infrastrure using code. In this post, we’ll see how we can create few EC2 intances, create SSH key pairs, and Security Group to controll access to the EC2 instances- all using code. We’ll login into the AWS Management Console to verify that everything is created as expected.</p>

<!--more-->

<h3 id="aws-cli">AWS CLI</h3>
<p>To access AWS services programmatically we need to install a piece of software from Amazon, AWS CLI. AWS CLI is written in Python, and is available as a Python package. Depending on the operating system, the instructions for downloading and installing AWS CLI is different. But for Linux/MacOSX users, the process is straight-forward:</p>
<pre>
$ sudo pip install awscli
</pre>

<p>Once installed, we can use the tool to interact with the AWS. For example, the command</p>
<pre>
$ aws ec2 describe-instances
</pre>
<p>will fetch a list of all instances. However, for this command to succedd, we have to configure AWS-CLI with the IAM user we created. The configuration is done using the command <code class="highlighter-rouge">$ aws configure</code>, and then providing the AWS Access key ID and AWS Secret Access key. These two pieces of information are found in the credential file we downloaded and copied in our <code class="highlighter-rouge">DevOps</code> folder. There are two other optional information to provide: default region and default output format. The region is the Amazon geographic region we want to use by default, and the output format is the format of information we’d like AWS to provide us in return when we exectue an <code class="highlighter-rouge">aws</code> command.</p>

<p>To verify if the user is good to go, we can issue the command: <code class="highlighter-rouge">$ aws ec2 describe-instances</code>. It should come back with a list of EC2 instances I might have in that default region.</p>

<h3 id="creating-ssh-key-pairs">Creating SSH Key Pairs</h3>
<p>We’ll need to create two EC2 instances, that we’ll use down the way for ansible. Before creating any EC2 instances, we’ll have to create keys for SSH access to these nodes password-free. Creating a key pair is easy, just issue <code class="highlighter-rouge">$ aws ec2 create-key-pair</code> and provide a name for the key. The <strong>important</strong> thing is however noting the private key created. We <strong>must</strong> copy (using mouse to select) the private key and save into our own desktop/laptop for further use. The following commands crate the keys we need. I called them:
<code class="highlighter-rouge">AnsibleControllerKey</code> and <code class="highlighter-rouge">HostForAnsibleKey</code>.</p>
<pre>
$ aws ec2 create-key-pair --key-name AnsibleControllerKey
$ aws ec2 create-key-pair --key-name HostForAnsibleKey
</pre>

<p>One nuisence in copying and pasting the private key is the <code class="highlighter-rouge">\n</code> character. The console adds them for readability
but we must remove them in the file. I saved the keys with names: <code class="highlighter-rouge">AnsibleControllerKey.pem</code> and <code class="highlighter-rouge">HostForAnsibleKey.pem</code>, in the <code class="highlighter-rouge">DevOps</code> folder. I also must make them non-readable to other users (Unix permission 400) using the command <code class="highlighter-rouge">chmod 400 AnsibleControllerKey.pem</code> and  <code class="highlighter-rouge">chmod 400 HostForAnsibleKey.pem</code></p>

<p>Though we have interacted with the AWS cloud directly using the AWS CLI command terminal, this is only suitable for small number of items. If we had to create a say one hundred key pairs, we would have never done that manually. In that case, someone would write a script, either shell or Python.</p>

<h3 id="creating-infrasture-using-codes">Creating Infrasture using Codes</h3>
<p>AWS <code class="highlighter-rouge">CloudFormation</code> service facilitates automated creation and management of infrastructure. The architectural configuration of the desired infrastructure is specified in either JSON or YAML format. From that configuration, CloudFormation can create the whole infrastructure, initialize OS, help install package etc so that the environment is ready to run an application. In technical term, the configuration settings are called a <em>stack</em>, and AWS offers predefined <em>stack template</em> for stacks for many common purposes. In addition, it offers a simple GUI based template builder/editor called CloudFormtion designer. There is a second tool called CloudFormer that can trawl through the instances etc already created in the AWS, and build a template based on these. And offcourse, it is possible to build a template from scratch.</p>

<h4 id="creating-stack-template-using-troposhpere">Creating Stack Template using Troposhpere</h4>
<p>To programmatically create a stack template, Python has a package <code class="highlighter-rouge">troposphere</code> available. To install:</p>
<pre>
$ sudo pip install troposphere
</pre>

<p>We then write the following script that will help us generate a stack template:</p>
<pre>
"""Generating CloudFormation template"""
from ipaddress import ip_network
from ipify import get_ip
from troposphere import (Base64, ec2, GetAtt, Join, Output, Parameter, Ref, Template)

ApplicationPort = "3000"

sgAnsible = ec2.SecurityGroup("SecurityGroup1", GroupDescription="SG for ansible controller",
    SecurityGroupIngress=[
        ec2.SecurityGroupRule(
            IpProtocol="tcp",
            FromPort="22",
            ToPort="22",
            CidrIp="0.0.0.0/0"
        )
    ]
)

instanceAnsibleController = ec2.Instance("AnsibleController", ImageId="ami-c998b6b2", 
    InstanceType="t1.micro", SecurityGroups=[Ref(sgAnsible)], 
    KeyName='AnsibleControllerKey')


sgHost = ec2.SecurityGroup("SecurityGroup2", GroupDescription="SG for host",
    SecurityGroupIngress=[
        ec2.SecurityGroupRule(
            IpProtocol="tcp",
            FromPort="22",
            ToPort="22",
            CidrIp="172.33.0.0/16"
        ),
        ec2.SecurityGroupRule(
            IpProtocol="tcp",
            FromPort=ApplicationPort,
            ToPort=ApplicationPort,
            CidrIp="0.0.0.0/0"
        )
    ]
)


instanceHostForAnsible = ec2.Instance("HostForAnsible", ImageId="ami-c998b6b2", 
    InstanceType="t1.micro", SecurityGroups=[Ref(sgHost)], 
    KeyName='HostForAnsibleKey')


t = Template()
t.add_description("CloudFormation Template")

t.add_resource(sgAnsible)
t.add_resource(sgHost)
t.add_resource(instanceAnsibleController)
t.add_resource(instanceHostForAnsible)

t.add_output(Output(
    "Instance1PublicIp",
    Description="Public Ip of our ansible controller instance.",
    Value=GetAtt("AnsibleController", "PublicIp")
))

t.add_output(Output(
    "Instance2PublicIp",
    Description="Public Ip of our host instance.",
    Value=GetAtt("HostForAnsible", "PublicIp")
))


print(t.to_json())
</pre>

<p>The code above contains statements to create two appropriate security groups, and then two EC2 instances. For the instance <code class="highlighter-rouge">AnsibleController</code> we allowed only SSH on port 22 from anywhere. Howeve, the actual application host node <code class="highlighter-rouge">instanceHostForAnsible</code> allows SSH on port 22 only from the controller host. It however allows tcp traffic on port 3000, that our application will serve.</p>

<p>We save the Python script as <code class="highlighter-rouge">cf-template.py</code> and then run from the termnial <code class="highlighter-rouge">$python cf-terminal.py</code>. It should spash out some JSON. Redirecting the output <code class="highlighter-rouge">$python cf-template.py &gt; cf-template.tpl</code> gives the template file that we are going to use with CloudFormation.</p>

<p>Once we have the template file, we log into the Maganagement Console, and select <code class="highlighter-rouge">CloudFormation</code> service. Click on <code class="highlighter-rouge">Create Stack</code>, then choose <code class="highlighter-rouge">Upload a template to Amazon S3</code> and select our template file. Clicking Next and then giving the stack a name takes to Options page. One more click on next button brings a summary of the template. Hitting the Create button starts craeting the EC2 instances, and the security group related to them.</p>

<p>To verify, we go to the EC2 dashboard and click on Instances:
 <img src="/blog/assets/images/2017/17_12_17/ec2-instances.png" alt="EC2 instances" class="leftimg" /></p>

<p>We can also verify the security groups if wished.</p>

<p>Few things to remember:</p>

<ul>
  <li>The image ID for EC2, amazon machine image (AMI) instances are not the same for different region. It has be the one that we are creating our EC2 instances on. The best way to look for the <code class="highlighter-rouge">ami</code> in trying to launch an EC2 manually from the management console.</li>
  <li><code class="highlighter-rouge">CloudFormation</code> does not (or can not) use existing security groups. The SGs need to be created along with the EC2 from the same stack template.</li>
</ul>

<p>In next post, I’ll install ansible and setup a small automated build and deployment system.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Continuous Integration and Continuous Deploypment on AWS : part I - setup IAM</title>
	  <link>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-I</link>
	  <author>alamgir</author>
	  <pubDate>2017-12-16T15:18:00-05:00</pubDate>
	  <guid>/blog//Continuous-Integration-and-Continuous-Deployment-using-AWS-part-I</guid>
	  <description><![CDATA[
	     <p><img src="/blog/assets/images/2017/17_12_16/cicd-0.png" alt="CICD" class="leftimg" />
DevOps philosophy has it that an application is better developed, tested and deployed in small pieces, in a continuous manner. This hopefully serves the changing requirements (of the clients or users) in both time and cost effective way. The developers, and operational team also always have something that is proved to be working, something to roll back to in case a change does not end successfully. To practically embrace the philosphy there needs to be an organizational pipeline where the teams (development, QA testing, deployment, monitoring etc) participate. And for better communication among the teams, most if not all teams use same kind of automation tools/platforms. This post is the first in a series of posts that talks about automation tools, employed on Amazon AWS cloud platform.</p>

<!--more-->

<h3 id="aws-setup">AWS Setup</h3>
<p>The first thing someone should do is to create an IAM user, and not use the root or main AWS account. It is straightforward- login to your AWS root account at: console.aws.amazon.com
<img src="/blog/assets/images/2017/17_12_16/aws-root-login.png" alt="AWS Root login" class="leftimg" />
If you have multi-factor authentication (MFA) enabled, a second screen will be appearing asking for authentication code. After successful login appears the AWS dashboard that lists many of the services AWS offers. A searchbox is readily available to quickly navigate to a service. We need the IAM service. Clicking on IAM will take to the IAM dashboard:
<img src="/blog/assets/images/2017/17_12_16/iam-dashboard.png" alt="IAM dashboard" class="leftimg" /></p>

<p>We need to create a new user (with limited priviledges) for all the exercises related to DevOps tools. Click on <code class="highlighter-rouge">Users</code> on the left pane, then <code class="highlighter-rouge">Add User</code> on the top to initiate the user creation process.
<img src="/blog/assets/images/2017/17_12_16/iam-add-user.png" alt="IAM Add User" class="leftimg" /></p>

<p>I am using <code class="highlighter-rouge">DevOpUser</code> as user name, and checking both <em>Programmatic</em> and <em>AWS Management Console</em> access check boxes. I am letting AWS autogenerate a password, but not forcing the user to reset the password.  Hitting <em>Next</em> will take us to permissions.</p>

<p>On Permissions screen, I am choosing the <em>Attach existing policies directly</em> option. Typing EC2 in the search box, I choose <code class="highlighter-rouge">EC2FullAceess</code> and <code class="highlighter-rouge">S3FullAccess</code>. Then follw next to finally create the user. I click on <strong>Download.csv</strong> button to save the login credentials for  newly created user <code class="highlighter-rouge">DevOpUser</code>. Also take note of the login url:
<code class="highlighter-rouge">https://xxxxxx.signin.aws.amazon.com/console</code> (xxxxxx denotes string I removed for privacy).
<img src="/blog/assets/images/2017/17_12_16/iam-add-user-done.png" alt="IAM Add User" class="leftimg" /></p>

<p>To keep things organized on my own local machine (a MacBook), I created a folder named <code class="highlighter-rouge">DevOps</code> under my home directory. The whole patch should be <code class="highlighter-rouge">/Users/&lt;username&gt;/DevOps</code>. I copy the credential file downloaded in the last step into this directory.</p>

<h3 id="more-aws-setup">More AWS Setup</h3>
<p>The user created above has full priviledge in using EC2 service. However, we need one more priviledge: access to <code class="highlighter-rouge">CloudFormation</code> so that we can create a set of EC2 instances from code, in an automated way. We go back to IAM service dashboard and click on <code class="highlighter-rouge">Users</code> on the left panel, then select the user <code class="highlighter-rouge">DevOpUser</code>. It should show a summary of the user, and a button at the bottom to add <code class="highlighter-rouge">inline policy</code>. I clicked on <code class="highlighter-rouge">Add inline policy</code> then chose <code class="highlighter-rouge">Custom Policy</code>, then finally pasted this piece of code in the editor:</p>
<pre>
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "cloudformation:Describe*",
                "cloudformation:List*",
                "cloudformation:Get*",
                "cloudformation:Create*",
                "cloudformation:Delete*",
                "cloudformation:Update*",
                "cloudformation:Validate*"
            ],
            "Resource": "*"
        }
    ]
}
</pre>

<p>I named the policy as <code class="highlighter-rouge">CloudFormationFullAccess</code>, then validated the policy before applying. Though validation should be enough, however if you want to be abolutely sure, there is an easy way to simulate the policies attached to the user. This simulation allows us to find out if the user has enough priviledges to do things it needs to. The simulator found at <a href="https://policysim.aws.amazon.com"> Amazon site </a>.</p>

<h3 id="testing-new-user">Testing new User</h3>
<p>The login url for (non-root) limited-rights user is different.  You shoul be able to see it immediately after creating the user. Generally it has the following format:</p>
<pre>
https://Root_Account_ID.signin.aws.amazon.com/console/
</pre>
<p>Where <code class="highlighter-rouge">Root_Accound_ID</code> is the either the account number or alias of the root account. Visiting the login link, and after providing the user name and password for <code class="highlighter-rouge">DevOpUser</code> I found this dashboard.
<img src="/blog/assets/images/2017/17_12_16/iam-user-dashboard.png" alt="User Dashboard" class="leftimg" />
This dashboard allows creating and managing AWS services. In addition to this dashboard, AWS allows creating and managing service resouces via programmatic access. In the next post we’ll see how to create EC2 instances
using AWS CLI (command line  interface).</p>


	  ]]></description>
	</item>


</channel>
</rss>
