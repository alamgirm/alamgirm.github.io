<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>https://alamgirm.github.io/blog/</title>
   
   <link>https://alamgirm.github.io</link>
   <description>Programming, Automation, Data Science, Machine Learning, Visualizations, Arduino, Raspberry Pi and other IoT.</description>
   <language>en_GB</language>
   <managingEditor> alamgir</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Inside ATMega AVR microcontroller</title>
	  <link>//Inside-ATmega-AVR</link>
	  <author>alamgir</author>
	  <pubDate>2017-06-14T08:18:00-04:00</pubDate>
	  <guid>//Inside-ATmega-AVR</guid>
	  <description><![CDATA[
	     <p><img src="/assets/images/2017/17_06_14_ATmega328P.jpg" alt="Atmel ATmega328P" class="rightimg" />Atmel offers a wide variety of AVR MCU available in different series or families. MCU from these families differ in capabilities and funcionalities and sometimes in instructions available and architecture. However,  the design of AVR itself followes some common philosophy that could help us understand the internal architecture of such an MCU. In this post we talk about Atmel ATmega MCU which are available in different parts numbers, and with differnt amount of program memory.</p>

<!--more-->

<h2 id="internal-architecture-of-atmega-family">Internal Architecture of ATmega family</h2>
<p>Looking at the block diagram of internal architecture of ATmega family one would notice that the MPU has:</p>

<ul>
  <li>Serial I/O communication for dowanloading of program</li>
  <li>Flash memory for storing program to be executed</li>
  <li>EEPROM (for storing CPU configuration bits)</li>
  <li>Peripheral I/O</li>
  <li>Analog/Digital converter</li>
  <li>Timers/counters</li>
  <li>Data memory</li>
  <li>CPU core (ALU, Program counter, general purpose registers etc)</li>
</ul>

<p><img src="/assets/images/2017/17_06_14_Atmel_ATmega_arch.png" alt="Atmel ATmega" title="Atmel ATmega MPU." /></p>

<p>AVR is based on modidfied Harvard architecture, so it is expected the program and data memory space tos be seperate. In addition to that, AVR allows readonly access to any data residing in the program memory, but no writes are allowed by the program itself. In addition to the memories for data and programs, AVR also has few bits of EEPROM for storing CPU configuration parameters (we’ll see later). When compared to a CPU like Intel 8080 or Zilog Z80, the ATmega has lots of other functionalities buil-it, to be justly called a microcontroller. Lets talk them in detail:</p>

<h4 id="serial-io">Serial I/O</h4>
<p>While Intel 8080 or Zilog Z80 needs a UART chip to communicate with the outside world via serial connection, ATmega has this functionality built right into the chip making serial communication trivial. Some chips offer USB commucations too.</p>

<h4 id="memories">Memories</h4>
<p>ATmega has flash memory for storing programs, and EEPROM for storing configuration parameters. Contents of both these memories are preserved when the power is off. Both these can be written from outside with appropriate tool. For storing temporary data there is data memory, which is in fact static RAM. The exact amount of thse memories vary depending on the model number.</p>

<h4 id="cpu">CPU</h4>
<p>The CPU core in AVR like most other CPU has ALU, Program Counter, and a host of general purspose registers. ATmega has 32 general purpose registers, each being 8-bit wide. The number and usage can slightly vary depending on the model. Surprisingly enough, these registers are mapped to first 32 bytes of the data memory. This meeans a program whishing to access the registers can simply read/wirte data to the specific memory locations. Last six of the 32 regisers are used as index registers, each in a 16-bit wide fashion. PC (program counter), a 14-bit special purpose register, points to the next executable instruction in <i>program memory</i>. When the MCU is first powered up, or reset, the PC is loaded to with value <code class="highlighter-rouge">0x0000</code> (this could be changed though). The SP (stack pointer) consists of two registers (taken from the total 32) and points to a memory location in <i>data memory</i>. In addition, AVR has few status regisers to reflect various operational status.</p>

<h4 id="peripheral-io">Peripheral I/O</h4>
<p>ATmega supports digital input/output of data with outside world, most likely from the same board. Some of these I/O can be analog, PWM (pulse width modulated) signals, others could be simple TTL (transistor transisto logic). Specilized communicatoin such as I2C, SPI, CAN bus can also be supported with proper support circuit and programs. Often there is an analog comparator that could be used for comparing analog signals. Digital data from/to outside world are stored in memory locations starting right after the 32 registers map. Though these locations are called I/O registers, they are not CPU registers, just ordinary memory locations mapped as an I/O port. Depending on model there could be 64 or more I/O registers.</p>

<h4 id="analogdigital-converter">Analog/Digital Converter</h4>
<p>ATmega has in-built A/D (Analog to Digital) converter. Some models have D/A (Digital to Analof) converter too. This allows interfacing with analog world without needing extranal A/D chips.</p>

<h4 id="timerscounters">Timers/Counters</h4>
<p>ATmega has on chip timers/counters, and thre are two kinds. The first kind is a 8-bit synchronous where the clock signal is derived from the CPU clock. The second kinds allows connecting an external clock circtuit to trigger the timer/counter and works independent of the CPU clock. Each of the timer/counter available can operate in a multiple of modes depending on application needs.
<img src="/assets/images/2017/17_06_14_Atmel_ATmega_arch2.png" alt="Atmel ATmega" title="Atmel ATmega MPU." /></p>

<h5 id="other-features">Other Features</h5>

<p>Depending on the model, certain models can have special sensors built-in, can have an LCD driver, LIN bus support etc.</p>

<h4 id="pin-configurations">Pin configurations</h4>
<p>An ATmega chip has many more functions than it has physical pins to support them for. To determine which functionalities are avalilable at which pins, ATmega has something called control register. Changing a suitable bit in the register can make a pin digital or analog, input or output, attach an intenal pull-up resistance etc. The timers/counters, communication interface, A/D etc can be configured by adjusting bits in the configuration control registers. The expectation with such design is that the user would configure the chip for his application need and the chip would just operate the way it is configured.</p>

<h4 id="watchdog-timer">Watchdog timer</h4>
<p>Though not shown in the picture, ATmega chips have a special timer, still programmable, called watchdog timer. This allows user programs or say an operating system to watch the MCU if it is stuck in a program execution. If that happens, a separate circuit can reset the MCU witout human intervention.</p>

<h4 id="credits">Credits</h4>
<ul>
  <li>The pictures in this article are courtesy of <a href="http://shop.oreilly.com/product/0636920037880.do">Arduino- A technical reference</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Modern microcontroller: AVR series</title>
	  <link>//modern-microcontroller-avr-group</link>
	  <author>alamgir</author>
	  <pubDate>2017-06-13T02:18:00-04:00</pubDate>
	  <guid>//modern-microcontroller-avr-group</guid>
	  <description><![CDATA[
	     <p>The story of AVR familiies of microcontrollers (MCU), that power popular Arduino development boards began with two Norwegian students who designed a microcontroller as academic project. It was based on modified Harvard achitecture and RISC instructions set. The design later bought up by Atmel, and the two original designers continued to work on and improve. <img src="/assets/images/2017/17_06_13_Atmel_AVR_logo.png" alt="AVR logo" class="rightimg" /> Atmel, understandly targetting the market of Intel 8051 releases the first AVR AT90S8515, a 8-bit MCU with same pin out as Intel 8051. Though originally 8-bit today AVR has 32-bit MCU, and offers multiple families of MCU with varied degree of capabilities and functionalities. There are however few common features: for example use of on-chip flash memory for program storage, EEPROM bits for CPU configuration flags etc. Within each family there are multiple MCUs available.</p>

<!--more-->

<h2 id="avr-families">AVR Families</h2>
<p>AVR MCUs are generally put into any of the following falimies:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>TinyAVR</th>
      <th>MegaAVR</th>
      <th>XMEGA</th>
      <th>AVR32</th>
      <th>App Specific</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Data memory</td>
      <td>uptp 1024</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Word size</td>
      <td>8-bit</td>
      <td>8-bit</td>
      <td>8-bit</td>
      <td>32-bit</td>
      <td>depends</td>
    </tr>
    <tr>
      <td>Program memory</td>
      <td>0.5 to 16KB</td>
      <td>4-256KB</td>
      <td>16-384KB</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Package</td>
      <td>6-32 pin</td>
      <td>28-100pin</td>
      <td>variable</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Peripheral</td>
      <td>limited</td>
      <td>extened</td>
      <td>extended</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Instrunctions</td>
      <td>Some limit</td>
      <td>Extened</td>
      <td>Extened</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Extra feature</td>
      <td>No</td>
      <td>Option</td>
      <td>Option</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="specific-models">Specific Models</h2>
<p>Below are some specifuc models that are used often. The table is not complete, and accuracy is not guranteed.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Flash memory</th>
      <th>EEPROM</th>
      <th>SRAM</th>
      <th>Chip pins</th>
      <th>I/O pins</th>
      <th>Clock</th>
      <th>Feature</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ATtiny13</td>
      <td>1K</td>
      <td>64</td>
      <td>160</td>
      <td>8</td>
      <td>6</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATtiny85</td>
      <td>8K</td>
      <td>512</td>
      <td>512</td>
      <td>8</td>
      <td>6</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATMega32</td>
      <td>32K</td>
      <td>1K</td>
      <td>2K</td>
      <td>40</td>
      <td>32</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega32U4</td>
      <td>32K</td>
      <td> </td>
      <td> </td>
      <td>44</td>
      <td>26</td>
      <td>16MHz</td>
      <td>USB</td>
    </tr>
    <tr>
      <td>ATmega128</td>
      <td>128K</td>
      <td> </td>
      <td> </td>
      <td>64</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega168</td>
      <td>16K</td>
      <td>512</td>
      <td>1K</td>
      <td>28/32</td>
      <td>23</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega328</td>
      <td>32K</td>
      <td>1K</td>
      <td>2K</td>
      <td>28/32</td>
      <td>23</td>
      <td>20MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega649</td>
      <td>64K</td>
      <td> </td>
      <td> </td>
      <td>64</td>
      <td> </td>
      <td> </td>
      <td>LSB</td>
    </tr>
    <tr>
      <td>ATmega1280</td>
      <td>128K</td>
      <td> </td>
      <td> </td>
      <td>100</td>
      <td>86</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
    <tr>
      <td>ATmega2560</td>
      <td>256K</td>
      <td> </td>
      <td> </td>
      <td>100</td>
      <td>86</td>
      <td>16MHz</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="more-details">More details</h3>

<p>More details about the features of various families can be found in <a href="http://www.atmel.com/products/microcontrollers/avr/default.aspx">Atmel’s web</a> site. Considering both the price and features, ATMega family is probably the best choice among IoT and hooby users. Choices and details about ATMega family chips are available <a href="http://www.atmel.com/products/microcontrollers/avr/megaavr.aspx"> here.</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
